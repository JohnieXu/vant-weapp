{"version":3,"sources":["index.js","crypt.js","crypto.js","util.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"decrypt\", {\n  enumerable: true,\n  get: function get() {\n    return _crypt.decrypt;\n  }\n});\nObject.defineProperty(exports, \"encrypt\", {\n  enumerable: true,\n  get: function get() {\n    return _crypt.encrypt;\n  }\n});\n\nvar _crypt = require(\"./crypt\");","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encrypt = exports.decrypt = void 0;\n\nvar _crypto = require(\"./crypto\");\n\n// const { resolveContent, createContent } = require('./tripledes3.js')\nvar decrypt = function decrypt(data, appKey) {\n  return (0, _crypto.resolveContent)(data, appKey);\n};\n\nexports.decrypt = decrypt;\n\nvar encrypt = function encrypt(data, appKey) {\n  return (0, _crypto.createContent)(data, appKey);\n};\n\nexports.encrypt = encrypt;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createContent = createContent;\nexports.decryptByDES = decryptByDES;\nexports.encryptByDES = encryptByDES;\nexports.resolveContent = resolveContent;\n\nvar _encHex = _interopRequireDefault(require(\"crypto-js/enc-hex\"));\n\nvar _tripledes = _interopRequireDefault(require(\"crypto-js/tripledes\"));\n\nvar _core = _interopRequireDefault(require(\"crypto-js/core\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-bitwise */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable func-names */\n\n/* eslint-disable no-underscore-dangle */\n// const Hex = require('crypto-js/enc-hex')\n// const TripleDES = require('crypto-js/tripledes')\n// const Core = require('crypto-js/core')\n\n/**\n * Electronic Codebook block mode.\n */\nvar CryptoECB = function () {\n  var ECB = _core.default.lib.BlockCipherMode.extend();\n\n  ECB.Encryptor = ECB.extend({\n    processBlock: function processBlock(words, offset) {\n      this._cipher.encryptBlock(words, offset);\n    }\n  });\n  ECB.Decryptor = ECB.extend({\n    processBlock: function processBlock(words, offset) {\n      this._cipher.decryptBlock(words, offset);\n    }\n  });\n  return ECB;\n}();\n/**\n* A noop padding strategy.\n*/\n\n\nvar NoPadding = {\n  pad: function pad() {},\n  unpad: function unpad() {}\n}; // 加密\n\nfunction encryptByDES(mpiKey, message, isSessionKey) {\n  mpiKey += mpiKey.substring(0, 16); // console.log(\"秘钥：\"+mpiKey)\n  // 转16进制\n  // console.log(message)\n  // 过程密钥不做填充\n\n  if (!isSessionKey) {\n    message = (0, _util.padding80)(message, true); // console.log('padding:'+message)\n  }\n\n  message = _encHex.default.parse(message); // console.log(`mpiKey: ${mpiKey}`)\n  // console.log(`message: ${message}`)\n\n  var keyHex = _encHex.default.parse(mpiKey);\n\n  var encrypted = _tripledes.default.encrypt(message, keyHex, {\n    mode: CryptoECB,\n    padding: NoPadding\n  }); // console.log(\"加密密文：\"+encrypted.ciphertext.toString().toUpperCase())\n\n\n  return encrypted.ciphertext.toString().toUpperCase();\n} // 3des解密\n\n\nfunction decryptByDES(mpiKey, ciphertext) {\n  // mpiKey = \"77c3052b141a481dd2f377c51571812c\"\n  mpiKey += mpiKey.substring(0, 16);\n\n  var keyHex = _encHex.default.parse(mpiKey);\n\n  ciphertext = _encHex.default.parse(ciphertext); // direct decrypt ciphertext\n\n  var decrypted = _tripledes.default.decrypt({\n    ciphertext: ciphertext\n  }, keyHex, {\n    mode: CryptoECB,\n    padding: NoPadding\n  });\n\n  var data = decrypted.toString(); // console.log(`data:${data}`)\n\n  data = (0, _util.hexCharCodeToStr)(data); // console.log('data2:'+data)\n\n  var num = data.lastIndexOf('80'); // 截取actionInfoString\n  // 最后一个'80'出现的位置\n\n  if (num !== -1) {\n    data = data.substring(0, num);\n  }\n\n  var result = (0, _util.hexCharCodeToStr)(data);\n  return result;\n}\n/**\n* 创建加密报文\n* @param config\n*/\n\n\nfunction createContent(config, appkey) {\n  // 最终生成密文\n  // 生成随机数\n  var randData = (0, _util.s2as)(32); // console.log(\"随机数:\"+randData)\n\n  var mpiKey = appkey; // 获取过程密钥\n\n  var processKey = encryptByDES(mpiKey, randData, true); // console.log(\"过程秘钥:\"+processKey)\n  // 加密ActionInfo\n  // console.log('json明文:'+JSON.stringify(config))\n\n  var src = (0, _util.strToHexCharCode)(JSON.stringify(config)); // console.log('16进制明文:'+src)\n\n  var actionInfo = encryptByDES(processKey, src, false);\n  var encStr = randData + actionInfo;\n  return encStr;\n} // 解析数据\n\n\nfunction resolveContent(actionInfo, appkey) {\n  var mpiKey = appkey; // 获取随机数\n\n  var randData = actionInfo.substring(0, 32); // console.log(`de-randData : ${randData}`)\n  // 获取应用密文\n\n  var singData = actionInfo.substring(32, actionInfo.length); // console.log(`de-enData : ${singData}`)\n  // 获取过程密钥\n\n  var processKey = encryptByDES(mpiKey, randData, true); // console.log(`de-processKey : ${processKey}`)\n  // 解密singData\n\n  var actionInfoString = decryptByDES(processKey, singData); // console.log(`de-HexString : ${actionInfoString}`)\n  // console.log(`actionInfoString:${actionInfoString}`)\n\n  var res;\n\n  try {\n    res = JSON.parse(actionInfoString);\n  } catch (e) {\n    res = actionInfoString;\n  } // console.log('parse json:'+json)\n\n\n  return res;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.byteToString = byteToString;\nexports.hexCharCodeToStr = hexCharCodeToStr;\nexports.hexDecode = hexDecode;\nexports.hexEncode = hexEncode;\nexports.padding80 = padding80;\nexports.s2as = s2as;\nexports.strToHexCharCode = strToHexCharCode;\nexports.stringToByte = stringToByte;\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-bitwise */\n\n/* eslint-disable no-plusplus */\nfunction s2as(length) {\n  var strNumber = '';\n\n  for (var i = 0; i < length; i++) {\n    strNumber += (Math.floor(Math.random() * 10000) % 10).toString();\n  }\n\n  var result = '';\n\n  for (var j = 0; j < strNumber.length; j++) {\n    result += String.fromCharCode(strNumber.substring(j, j + 1).charCodeAt());\n  }\n\n  return result;\n} // 字符串转16进制\n\n\nfunction strToHexCharCode(str) {\n  // 根据默认编码获取字节数组\n  var bytes = stringToByte(str);\n  var hexString = '0123456789abcdef';\n  var sb = ''; // 将字节数组中每个字节拆解成2位16进制整数\n\n  for (var i = 0; i < bytes.length; i++) {\n    sb += hexString.charAt((bytes[i] & 0xf0) >> 4);\n    sb += hexString.charAt((bytes[i] & 0x0f) >> 0);\n  }\n\n  return sb.toString();\n} // 16进制转字符串\n\n\nfunction hexCharCodeToStr(hexCharCodeStr) {\n  var baos = [];\n  var hexString = '0123456789abcdef'; // 将每2位16进制整数组装成一个字节\n\n  for (var i = 0; i < hexCharCodeStr.length; i += 2) {\n    baos.push(hexString.indexOf(hexCharCodeStr.charAt(i)) << 4 | hexString.indexOf(hexCharCodeStr.charAt(i + 1)));\n  }\n\n  return byteToString(baos);\n} // 补80\n\n\nfunction padding80(data) {\n  var toHex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var padlen = 8 - data.length / 2 % 8;\n  var padstr = '';\n\n  for (var i = 0; i < padlen - 1; i++) {\n    padstr += '00';\n  }\n\n  data = \"\".concat(data, \"80\").concat(padstr);\n  data = toHex ? strToHexCharCode(data) : data;\n  return data;\n} // 字节转string\n\n\nfunction byteToString(arr) {\n  if (typeof arr === 'string') {\n    return arr;\n  }\n\n  var str = '';\n  var _arr = arr;\n\n  for (var i = 0; i < _arr.length; i++) {\n    var one = _arr[i].toString(2);\n\n    var v = one.match(/^1+?(?=0)/);\n\n    if (v && one.length === 8) {\n      var bytesLength = v[0].length;\n\n      var store = _arr[i].toString(2).slice(7 - bytesLength);\n\n      for (var st = 1; st < bytesLength; st++) {\n        store += _arr[st + i].toString(2).slice(2);\n      }\n\n      str += String.fromCharCode(parseInt(store, 2));\n      i += bytesLength - 1;\n    } else {\n      str += String.fromCharCode(_arr[i]);\n    }\n  }\n\n  return str;\n} // string转字节\n\n\nfunction stringToByte(str) {\n  var bytes = [];\n  var len;\n  var c; // eslint-disable-next-line prefer-const\n\n  len = str.length;\n\n  for (var i = 0; i < len; i++) {\n    c = str.charCodeAt(i);\n\n    if (c >= 0x010000 && c <= 0x10ffff) {\n      bytes.push(c >> 18 & 0x07 | 0xf0);\n      bytes.push(c >> 12 & 0x3f | 0x80);\n      bytes.push(c >> 6 & 0x3f | 0x80);\n      bytes.push(c & 0x3f | 0x80);\n    } else if (c >= 0x000800 && c <= 0x00ffff) {\n      bytes.push(c >> 12 & 0x0f | 0xe0);\n      bytes.push(c >> 6 & 0x3f | 0x80);\n      bytes.push(c & 0x3f | 0x80);\n    } else if (c >= 0x000080 && c <= 0x0007ff) {\n      bytes.push(c >> 6 & 0x1f | 0xc0);\n      bytes.push(c & 0x3f | 0x80);\n    } else {\n      bytes.push(c & 0xff);\n    }\n  }\n\n  return bytes;\n}\n/**\n * @deprecated 此方法转换有误，使用 strToHexCharCode 方法代替\n * @param {String} str 待转换的字符串\n * @returns 十六进制字符串\n */\n\n\nfunction hexEncode(str) {\n  var hex;\n  var i;\n  var result = '';\n\n  for (i = 0; i < str.length; i++) {\n    hex = str.charCodeAt(i).toString(16);\n    result += \"000\".concat(hex).slice(-4);\n  }\n\n  return result;\n}\n/**\n * @deprecated 此方法转换有误，使用 hexCharCodeToStr 方法代替\n * @param {String} str 待转换的十六进制字符串\n * @returns 字符串\n */\n\n\nfunction hexDecode(str) {\n  var j;\n  var hexes = str.match(/.{1,4}/g) || [];\n  var back = '';\n\n  for (j = 0; j < hexes.length; j++) {\n    back += String.fromCharCode(parseInt(hexes[j], 16));\n  }\n\n  return back;\n}"]}